# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `vernier` gem.
# Please instead update this file by running `bin/tapioca gem vernier`.


module Vernier
  class << self
    def memory_rss; end
    def profile(mode: T.unsafe(nil), **collector_options); end
    def run(mode: T.unsafe(nil), **collector_options); end
    def start_profile(mode: T.unsafe(nil), **collector_options); end
    def stop_profile; end
    def trace(mode: T.unsafe(nil), **collector_options); end
    def trace_retained(**profile_options, &block); end
  end
end

class Vernier::Collector
  def initialize(mode, options = T.unsafe(nil)); end

  def add_marker(name:, start:, finish:, thread: T.unsafe(nil), phase: T.unsafe(nil), data: T.unsafe(nil)); end
  def current_time; end
  def record_interval(category, name = T.unsafe(nil)); end
  def stack_table; end
  def stop; end

  private

  def add_hook(hook); end

  class << self
    def new(mode, options = T.unsafe(nil)); end
  end
end

class Vernier::Collector::CustomCollector < ::Vernier::Collector
  def initialize(mode, options); end

  def finish; end
  def sample; end
  def start; end
end

class Vernier::Collector::RetainedCollector < ::Vernier::Collector
  def initialize(mode, options); end

  def drain; end
  def finish; end
  def start; end
end

class Vernier::Collector::TimeCollector < ::Vernier::Collector
  def start; end

  private

  def finish; end

  class << self
    def new(_arg0, _arg1); end
  end
end

class Vernier::Error < ::StandardError; end

class Vernier::HeapTracker
  def allocated_objects; end
  def collect; end
  def data; end
  def drain; end
  def freed_objects; end
  def inspect; end
  def lock; end
  def stack(obj); end
  def stack_idx(_arg0); end
  def stack_table; end
  def track; end

  class << self
    def _new(_arg0); end
    def new(stack_table = T.unsafe(nil)); end
    def track(&block); end
  end
end

module Vernier::Hooks; end

class Vernier::Hooks::ActiveSupport
  def initialize(collector); end

  def disable; end
  def enable; end
  def firefox_marker_schema; end
end

Vernier::Hooks::ActiveSupport::FIREFOX_MARKER_SCHEMA = T.let(T.unsafe(nil), Array)
Vernier::Hooks::ActiveSupport::SERIALIZED_KEYS = T.let(T.unsafe(nil), Hash)

class Vernier::Hooks::MemoryUsage
  def initialize(collector); end

  def disable; end
  def enable; end
  def firefox_counters; end
end

module Vernier::Marker
  class << self
    def name_table; end
  end
end

Vernier::Marker::MARKER_STRINGS = T.let(T.unsafe(nil), Array)
Vernier::Marker::MARKER_SYMBOLS = T.let(T.unsafe(nil), Array)
module Vernier::Marker::Phase; end
Vernier::Marker::Phase::INSTANT = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Phase::INTERVAL = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Phase::INTERVAL_END = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Phase::INTERVAL_START = T.let(T.unsafe(nil), Integer)
module Vernier::Marker::Type; end
Vernier::Marker::Type::FIBER_SWITCH = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GC_END_MARK = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GC_END_SWEEP = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GC_ENTER = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GC_EXIT = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GC_PAUSE = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GC_START = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GVL_THREAD_EXITED = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::GVL_THREAD_STARTED = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::THREAD_RUNNING = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::THREAD_STALLED = T.let(T.unsafe(nil), Integer)
Vernier::Marker::Type::THREAD_SUSPENDED = T.let(T.unsafe(nil), Integer)

class Vernier::MemoryLeakDetector
  def initialize(collect_time:, idle_time: T.unsafe(nil), drain_time: T.unsafe(nil), **collector_options); end

  def result; end
  def start_thread; end

  class << self
    def start_thread(*_arg0, **_arg1, &_arg2); end
  end
end

class Vernier::MemoryTracker
  def record; end
  def results; end
  def start; end
  def stop; end
end

class Vernier::Middleware
  def initialize(app, permit: T.unsafe(nil)); end

  def call(env); end
end

module Vernier::Output; end

class Vernier::Output::Cpuprofile
  def initialize(profile); end

  def output; end

  private

  def build_nodes; end
  def calculate_time_deltas(timestamps); end
  def create_node_for_stack(stack_idx, nodes, stack_table); end
  def data; end
  def empty_profile; end
  def ns_to_us(timestamp); end
  def profile; end
  def root_node; end
  def stack_to_node_id(stack_idx); end
end

class Vernier::Output::FileListing
  def initialize(profile); end

  def format_file(output, filename, all_samples, total:); end
  def format_file_html(output, filename, relevant_files); end
  def html_output(output, relevant_files); end
  def output(template: T.unsafe(nil)); end
  def samples_by_file; end
  def total; end
end

class Vernier::Output::FileListing::SamplesByLocation
  def initialize; end

  def +(other); end
  def self; end
  def self=(_arg0); end
  def total; end
  def total=(_arg0); end
end

class Vernier::Output::FilenameFilter
  def initialize; end

  def call(filename); end
  def gem_match_regex; end
  def gem_regex; end
  def pwd; end
  def rubylibdir; end
end

class Vernier::Output::Firefox
  def initialize(profile); end

  def output(gzip: T.unsafe(nil)); end

  private

  def counter_data; end
  def data; end
  def marker_schema; end
  def profile; end
end

class Vernier::Output::Firefox::Categorizer
  def initialize; end

  def add_category(name:, **kw); end
  def categories; end
  def categorize(path); end
  def gem_path(*names); end
  def get_category(name); end
  def starts_with(*paths); end
end

Vernier::Output::Firefox::Categorizer::AVAILABLE_COLORS = T.let(T.unsafe(nil), Array)

class Vernier::Output::Firefox::Categorizer::Category
  def initialize(idx, name:, color:, matcher: T.unsafe(nil)); end

  def add_subcategory(**args); end
  def color; end
  def idx; end
  def matcher; end
  def matches?(path); end
  def name; end
  def subcategories; end
end

Vernier::Output::Firefox::Categorizer::ORDERED_CATEGORIES = T.let(T.unsafe(nil), Array)
Vernier::Output::Firefox::Categorizer::RAILS_COMPONENTS = T.let(T.unsafe(nil), Array)

class Vernier::Output::Firefox::Thread
  def initialize(ruby_thread_id, profile, categorizer, name:, tid:, samples:, weights:, markers:, started_at:, timestamps: T.unsafe(nil), sample_categories: T.unsafe(nil), stopped_at: T.unsafe(nil), allocations: T.unsafe(nil), is_main: T.unsafe(nil), is_start: T.unsafe(nil)); end

  def allocations_table; end
  def categorize_filename(filename); end
  def cfunc_category_and_subcategory; end
  def data; end
  def filter_filenames(filenames); end
  def find_category_and_subcategory(filename, categories); end
  def frame_table; end
  def func_table; end
  def is_start; end
  def markers_table; end
  def profile; end
  def ruby_category_and_subcategory; end
  def samples_table; end
  def stack_table; end
  def string_table; end

  private

  def gc_category; end
  def thread_category; end
end

class Vernier::Output::Top
  def initialize(profile, row_limit); end

  def output; end
end

class Vernier::Output::Top::Table
  def initialize(header, row_limit); end

  def <<(row); end
  def format_row(row); end
  def row_separator; end
  def to_s; end
  def widths; end
end

class Vernier::ParsedProfile
  def initialize(data); end

  def data; end
  def main_thread; end
  def threads; end

  class << self
    def read_file(filename); end
  end
end

class Vernier::ParsedProfile::StackTable
  include ::Vernier::StackTableHelpers

  def initialize(thread_data); end

  def frame_count; end
  def frame_func_idx(idx); end
  def frame_line_no(idx); end
  def func_count; end
  def func_filename(idx); end
  def func_filename_idx(idx); end
  def func_first_lineno(idx); end
  def func_name(idx); end
  def func_name_idx(idx); end
  def stack_count; end
  def stack_frame_idx(idx); end
  def stack_parent_idx(idx); end
  def strings; end
end

class Vernier::ParsedProfile::Thread
  def initialize(data); end

  def [](name); end
  def data; end
  def main_thread?; end
  def samples; end
  def stack_table; end
  def weights; end
end

class Vernier::Result
  def _stack_table; end
  def each_sample; end
  def elapsed_seconds; end
  def end_time; end
  def end_time=(_arg0); end
  def gc_markers; end
  def hooks; end
  def hooks=(_arg0); end
  def inspect; end
  def main_thread; end
  def meta; end
  def pid; end
  def pid=(_arg0); end
  def stack(idx); end
  def stack_table; end
  def stack_table=(_arg0); end
  def started_at; end
  def threads; end
  def to_cpuprofile; end
  def to_firefox(gzip: T.unsafe(nil)); end
  def to_gecko(gzip: T.unsafe(nil)); end
  def total_bytes; end
  def total_samples; end
  def total_unique_samples; end
  def total_weights; end
  def write(out:, format: T.unsafe(nil)); end
end

class Vernier::StackTable
  include ::Vernier::StackTableHelpers

  def convert(_arg0, _arg1); end
  def current_stack(*_arg0); end
  def finalize; end
  def frame_count; end
  def frame_func_idx(_arg0); end
  def frame_line_no(_arg0); end
  def func_absolute_path(_arg0); end
  def func_count; end
  def func_filename(_arg0); end
  def func_first_lineno(_arg0); end
  def func_name(_arg0); end
  def func_path(_arg0); end
  def stack_count; end
  def stack_frame_idx(_arg0); end
  def stack_parent_idx(_arg0); end

  class << self
    def new; end
  end
end

module Vernier::StackTableHelpers
  def backtrace(stack_idx); end
  def full_stack(stack_idx); end
  def inspect; end
  def stack(idx); end
  def to_h; end
end

class Vernier::StackTableHelpers::BaseType
  def initialize(stack_table, idx); end

  def idx; end
  def inspect; end
  def stack_table; end
end

class Vernier::StackTableHelpers::Frame < ::Vernier::StackTableHelpers::BaseType
  def filename; end
  def func; end
  def label; end
  def line; end
  def lineno; end
  def name; end
  def to_s; end
end

class Vernier::StackTableHelpers::Func < ::Vernier::StackTableHelpers::BaseType
  def filename; end
  def label; end
  def name; end
  def to_s; end
end

class Vernier::StackTableHelpers::Stack < ::Vernier::StackTableHelpers::BaseType
  def [](offset); end
  def each; end
  def each_frame; end
  def frames; end
  def leaf_frame; end
  def leaf_frame_idx; end
  def to_s; end
end

class Vernier::ThreadNames
  def initialize; end

  def [](object_id); end
  def finish; end

  private

  def collect_running; end
  def collect_thread(th); end
  def pretty_name(thread); end
end

Vernier::VERSION = T.let(T.unsafe(nil), String)

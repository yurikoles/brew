# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `test-prof` gem.
# Please instead update this file by running `bin/tapioca gem test-prof`.


module Minitest; end

class Minitest::Test < ::Minitest::Runnable
  include ::Minitest::TestProf::FactoryDoctorIgnore
end

module Minitest::TestProf; end

class Minitest::TestProf::BaseReporter < ::Minitest::AbstractReporter
  include ::TestProf::Logging

  def initialize(io = T.unsafe(nil), _options = T.unsafe(nil)); end

  def after_test(test); end
  def before_test(test); end
  def io; end
  def io=(_arg0); end
  def prerecord(group, example); end
  def record(*_arg0); end
  def report; end
  def start; end

  private

  def inject_to_minitest_reporters; end
  def location(group, example = T.unsafe(nil)); end
  def location_with_line_number(group, example = T.unsafe(nil)); end
  def location_without_line_number(group, example = T.unsafe(nil)); end
end

class Minitest::TestProf::EventProfFormatter
  def initialize(profilers); end

  def prepare_results; end

  private

  def by_examples(profiler); end
  def by_groups(profiler); end
  def time_percentage(time, total_time); end
  def total_results(profiler); end
end

class Minitest::TestProf::EventProfReporter < ::Minitest::TestProf::BaseReporter
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  def before_test(test); end
  def prerecord(group, example); end
  def record(*_arg0); end
  def report; end

  private

  def change_current_group(group, example); end
  def configure_profiler(options); end
  def track_current_example(group, example); end
end

module Minitest::TestProf::FactoryDoctorIgnore
  def fd_ignore; end
end

class Minitest::TestProf::FactoryDoctorReporter < ::Minitest::TestProf::BaseReporter
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  def prerecord(_group, _example); end
  def record(example); end
  def report; end

  private

  def pluralize_records(count); end
end

Minitest::TestProf::FactoryDoctorReporter::SUCCESS_MESSAGE = T.let(T.unsafe(nil), String)

class Minitest::TestProf::MemoryProfReporter < ::Minitest::TestProf::BaseReporter
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  def current_example; end
  def prerecord(group, example); end
  def printer; end
  def record(example); end
  def report; end
  def start; end
  def tracker; end

  private

  def configure_profiler(options); end
  def set_current_example(group, example); end
end

module Process
  class << self
    def clock_gettime_for_test_prof(*_arg0); end
    def singleton_method_added(method_name); end
  end
end

module TestProf
  extend ::TestProf::Logging

  class << self
    def activate(env_var, val = T.unsafe(nil)); end
    def artifact_path(filename); end
    def asset_path(filename); end
    def config; end
    def configure; end
    def create_artifact_dir; end
    def dry_run?; end
    def minitest?; end
    def now; end
    def require(gem_name, msg = T.unsafe(nil)); end
    def rspec?; end
    def spring?; end

    private

    def activate!(env_var, val); end
    def notify_spring_activate(env_var); end
    def notify_spring_detected; end
    def with_report_suffix(path); end
    def with_timestamps(path); end
  end
end

class TestProf::Configuration
  def initialize; end

  def color; end
  def color=(_arg0); end
  def color?; end
  def logger; end
  def output; end
  def output=(_arg0); end
  def output_dir; end
  def output_dir=(_arg0); end
  def report_suffix; end
  def report_suffix=(_arg0); end
  def timestamps; end
  def timestamps=(_arg0); end
  def timestamps?; end
end

module TestProf::EventProf
  class << self
    def build(event = T.unsafe(nil)); end
    def config; end
    def configure; end
    def instrumenter; end
    def monitor(mod, event, *mids, **kwargs); end
  end
end

class TestProf::EventProf::Configuration
  def initialize; end

  def event; end
  def event=(_arg0); end
  def instrumenter; end
  def instrumenter=(_arg0); end
  def per_example; end
  def per_example=(_arg0); end
  def per_example?; end
  def rank_by; end
  def rank_by=(_arg0); end
  def resolve_instrumenter; end
  def stamp?; end
  def top_count; end
  def top_count=(_arg0); end
end

TestProf::EventProf::Configuration::INSTRUMENTERS = T.let(T.unsafe(nil), Hash)

module TestProf::EventProf::CustomEvents
  class << self
    def activate_all(events); end
    def register(event, &block); end
    def try_activate(event); end

    private

    def registrations; end
  end
end

module TestProf::EventProf::Instrumentations; end

module TestProf::EventProf::Instrumentations::ActiveSupport
  class << self
    def instrument(event); end
    def subscribe(event, &block); end
  end
end

class TestProf::EventProf::Instrumentations::ActiveSupport::Subscriber
  def initialize(block); end

  def block; end
  def finish(*_arg0); end
  def publish(_name, started_at, finished_at, *_arg3); end
  def start(*_arg0); end
  def started_at; end
end

module TestProf::EventProf::Monitor
  class << self
    def call(mod, event, *mids, guard: T.unsafe(nil), top_level: T.unsafe(nil)); end
  end
end

class TestProf::EventProf::Monitor::BaseTracker
  def initialize(event); end

  def event; end
  def track; end
end

class TestProf::EventProf::Monitor::TopLevelTracker < ::TestProf::EventProf::Monitor::BaseTracker
  def initialize(event); end

  def id; end
  def track; end
end

class TestProf::EventProf::Profiler
  def initialize(event:, instrumenter:, rank_by: T.unsafe(nil), top_count: T.unsafe(nil), per_example: T.unsafe(nil)); end

  def absolute_run_time; end
  def count; end
  def event; end
  def example_count; end
  def example_finished(id); end
  def example_started(id); end
  def example_time; end
  def group_finished(id); end
  def group_started(id); end
  def per_example; end
  def per_example?; end
  def rank_by; end
  def results; end
  def take_time(start_ts); end
  def time; end
  def top_count; end
  def total_count; end
  def total_time; end
  def track(time); end

  private

  def reset_example!; end
  def reset_group!; end
end

class TestProf::EventProf::ProfilersGroup
  def initialize(event:, **options); end

  def each(&block); end
  def events; end
  def example_finished(id); end
  def example_started(id); end
  def group_finished(id); end
  def group_started(id); end
  def profilers; end
end

module TestProf::FactoryAllStub
  class << self
    def disable!; end
    def enable!; end
    def enabled?; end
    def init; end
  end
end

module TestProf::FactoryAllStub::FactoryBotPatch
  def run(_strategy = T.unsafe(nil)); end
end

TestProf::FactoryAllStub::LOCAL_NAME = T.let(T.unsafe(nil), Symbol)
module TestProf::FactoryBotStrategy; end

module TestProf::FactoryDoctor
  extend ::TestProf::Logging

  class << self
    def config; end
    def configure; end
    def count; end
    def ignore; end
    def ignore!; end
    def ignore?; end
    def init; end
    def queries_count; end
    def result; end
    def stamp?; end
    def start; end
    def stop; end
    def time; end
    def within_factory(strategy); end

    private

    def reset!; end
    def running?; end
    def subscribe!; end
    def within_factory?; end
  end
end

class TestProf::FactoryDoctor::Configuration
  def initialize; end

  def event; end
  def event=(_arg0); end
  def threshold; end
  def threshold=(_arg0); end
end

module TestProf::FactoryDoctor::FabricationPatch
  def create(*_arg0); end
end

module TestProf::FactoryDoctor::FactoryBotPatch
  def run(strategy = T.unsafe(nil)); end
end

TestProf::FactoryDoctor::IGNORED_QUERIES_PATTERN = T.let(T.unsafe(nil), Regexp)

class TestProf::FactoryDoctor::Result
  def initialize(count, time, queries_count); end

  def bad?; end
  def count; end
  def queries_count; end
  def time; end
end

module TestProf::FactoryProf
  extend ::TestProf::Logging

  class << self
    def config; end
    def configure; end
    def init; end
    def patch!; end
    def print(started_at); end
    def result; end
    def run; end
    def start; end
    def stop; end
    def track(factory, variation:); end

    private

    def flush_stack; end
    def hash_template(name); end
    def reset!; end
    def running?; end
    def track_count(factory); end
    def track_time(factory, t1, t2); end
    def variation_name(variation); end
  end
end

class TestProf::FactoryProf::Configuration
  def initialize; end

  def flamegraph?; end
  def include_variations; end
  def include_variations=(_arg0); end
  def include_variations?; end
  def mode; end
  def mode=(_arg0); end
  def printer; end
  def printer=(_arg0); end
  def threshold; end
  def threshold=(_arg0); end
  def truncate_names; end
  def truncate_names=(_arg0); end
  def variations_limit; end
  def variations_limit=(_arg0); end
end

TestProf::FactoryProf::FACTORY_BUILDERS = T.let(T.unsafe(nil), Array)

module TestProf::FactoryProf::FabricationPatch
  def create(name, overrides = T.unsafe(nil)); end
end

module TestProf::FactoryProf::FactoryBotPatch
  def run(strategy = T.unsafe(nil)); end
end

module TestProf::FactoryProf::FactoryBuilders; end

class TestProf::FactoryProf::FactoryBuilders::Fabrication
  class << self
    def patch; end
    def track(factory, **opts, &block); end
  end
end

class TestProf::FactoryProf::FactoryBuilders::FactoryBot
  class << self
    def patch; end
    def track(strategy, factory, **opts, &block); end
  end
end

module TestProf::FactoryProf::Printers; end

module TestProf::FactoryProf::Printers::Flamegraph
  extend ::TestProf::Logging

  class << self
    def convert_stacks(result); end
    def dump(result, **_arg1); end
  end
end

TestProf::FactoryProf::Printers::Flamegraph::OUTPUT_NAME = T.let(T.unsafe(nil), String)
TestProf::FactoryProf::Printers::Flamegraph::TEMPLATE = T.let(T.unsafe(nil), String)

module TestProf::FactoryProf::Printers::Json
  extend ::TestProf::Logging

  class << self
    def convert_stats(result, start_time); end
    def dump(result, start_time:, **_arg2); end
  end
end

module TestProf::FactoryProf::Printers::NateHeckler
  extend ::TestProf::Logging

  class << self
    def dump(result, start_time:, **_arg2); end
  end
end

module TestProf::FactoryProf::Printers::Simple
  extend ::TestProf::Logging

  class << self
    def dump(result, start_time:, threshold:, truncate_names:); end

    private

    def format_args(stat); end
    def format_string(indent_len, name_len, truncate_names); end
    def formatted(indent_len, name_len, truncate_names, stat); end
  end
end

class TestProf::FactoryProf::Result
  def initialize(stacks, raw_stats); end

  def raw_stats; end
  def stacks; end
  def stats; end
  def total_count; end
  def total_time; end
end

module TestProf::FloatDuration; end

module TestProf::Logging
  def log(level, msg); end
end

TestProf::Logging::COLORS = T.let(T.unsafe(nil), Hash)

class TestProf::Logging::Formatter
  def call(severity, _time, progname, msg); end

  private

  def colorize(level, msg); end
end

module TestProf::MemoryProf
  class << self
    def config; end
    def configure; end
    def printer(tracker); end
    def tracker; end
  end
end

class TestProf::MemoryProf::AllocPrinter < ::TestProf::MemoryProf::Printer
  private

  def memory_amount(item); end
  def mode; end
  def print_total; end
end

class TestProf::MemoryProf::AllocTracker < ::TestProf::MemoryProf::Tracker
  def supported?; end
  def track; end
end

class TestProf::MemoryProf::Configuration
  def initialize; end

  def mode; end
  def mode=(value); end
  def top_count; end
  def top_count=(value); end
end

class TestProf::MemoryProf::Printer
  include ::TestProf::Logging

  def initialize(tracker); end

  def print; end

  private

  def memory_percentage(item); end
  def number_to_human(value); end
  def print_block(name, items); end
  def print_items(items); end
  def tracker; end
end

module TestProf::MemoryProf::Printer::NumberToHuman
  class << self
    def convert(number); end

    private

    def exponent(number); end
    def integer?(number); end
    def round(number); end
  end
end

TestProf::MemoryProf::Printer::NumberToHuman::BASE = T.let(T.unsafe(nil), Integer)
TestProf::MemoryProf::Printer::NumberToHuman::UNITS = T.let(T.unsafe(nil), Array)

class TestProf::MemoryProf::RssPrinter < ::TestProf::MemoryProf::Printer
  private

  def memory_amount(item); end
  def mode; end
  def print_total; end
end

class TestProf::MemoryProf::RssTracker < ::TestProf::MemoryProf::Tracker
  def initialize(top_count); end

  def supported?; end
  def track; end
end

class TestProf::MemoryProf::Tracker
  def initialize(top_count); end

  def example_finished(id); end
  def example_started(id, example = T.unsafe(nil)); end
  def examples; end
  def finish; end
  def group_finished(id); end
  def group_started(id, group = T.unsafe(nil)); end
  def groups; end
  def list; end
  def start; end
  def top_count; end
  def total_memory; end
end

class TestProf::MemoryProf::Tracker::LinkedList
  def initialize(memory_at_start); end

  def add_node(id, item, memory_at_start); end
  def head; end
  def remove_node(id, memory_at_finish); end
end

class TestProf::MemoryProf::Tracker::LinkedListNode
  def initialize(id:, item:, memory_at_start:, previous:); end

  def finish(memory_at_finish); end
  def hooks_memory; end
  def id; end
  def item; end
  def memory_at_finish; end
  def memory_at_start; end
  def nested_memory; end
  def previous; end
  def total_memory; end

  protected

  def add_nested(node); end
end

module TestProf::MemoryProf::Tracker::RssTool
  class << self
    def os_type; end
    def tool; end
  end
end

class TestProf::MemoryProf::Tracker::RssTool::GetProcess
  def track; end

  private

  def command; end
end

class TestProf::MemoryProf::Tracker::RssTool::PS
  def track; end
end

class TestProf::MemoryProf::Tracker::RssTool::ProcFS
  def initialize; end

  def track; end

  private

  def get_page_size; end
end

TestProf::MemoryProf::Tracker::RssTool::TOOLS = T.let(T.unsafe(nil), Hash)

module TestProf::RSpecStamp
  extend ::TestProf::Logging

  class << self
    def apply_tags(code, lines, tags); end
    def config; end
    def configure; end

    private

    def quote(str); end
    def stamp_example(example, tags); end
  end
end

class TestProf::RSpecStamp::Configuration
  def initialize; end

  def dry_run; end
  def dry_run=(_arg0); end
  def dry_run?; end
  def ignore_files; end
  def ignore_files=(_arg0); end
  def tags; end
  def tags=(val); end

  private

  def parse_tags(str); end
end

TestProf::RSpecStamp::EXAMPLE_RXP = T.let(T.unsafe(nil), Regexp)

module TestProf::RSpecStamp::Parser
  class << self
    def parse(code); end

    private

    def parse_arg(res, arg); end
    def parse_const(expr); end
    def parse_hash(res, hash_arg); end
    def parse_literal(expr); end
    def parse_value(expr); end
  end
end

class TestProf::RSpecStamp::Parser::Result
  def add_htag(k, v); end
  def add_tag(v); end
  def desc; end
  def desc=(_arg0); end
  def desc_const; end
  def desc_const=(_arg0); end
  def fname; end
  def fname=(_arg0); end
  def htags; end
  def remove_tag(tag); end
  def tags; end
end

class TestProf::RSpecStamp::Stamper
  include ::TestProf::Logging

  def initialize; end

  def failed; end
  def ignored; end
  def stamp_file(file, lines); end
  def total; end

  private

  def dry_run?; end
  def ignored?(file); end
end

module TestProf::RubyProf
  extend ::TestProf::Logging

  class << self
    def config; end
    def configure; end
    def profile(locked: T.unsafe(nil)); end
    def run; end

    private

    def check_ruby_prof_version; end
    def exclude_common_methods(profiler); end
    def exclude_rspec_methods(profiler); end
    def init_ruby_prof; end
    def locked?; end
  end
end

class TestProf::RubyProf::Configuration
  def initialize; end

  def custom_exclusions; end
  def custom_exclusions=(_arg0); end
  def exclude_common_methods; end
  def exclude_common_methods=(_arg0); end
  def exclude_common_methods?; end
  def include_threads; end
  def include_threads=(_arg0); end
  def include_threads?; end
  def min_percent; end
  def min_percent=(_arg0); end
  def mode; end
  def mode=(_arg0); end
  def printer; end
  def printer=(_arg0); end
  def resolve_printer; end
  def ruby_prof_mode; end
  def skip_boot; end
  def skip_boot=(_arg0); end
  def skip_boot?; end
  def test_prof_exclusions_enabled; end
  def test_prof_exclusions_enabled=(_arg0); end
  def test_prof_exclusions_enabled?; end
end

TestProf::RubyProf::Configuration::LOGFILE_PREFIX = T.let(T.unsafe(nil), String)
TestProf::RubyProf::Configuration::PRINTERS = T.let(T.unsafe(nil), Hash)
TestProf::RubyProf::Configuration::PRINTER_EXTENSTION = T.let(T.unsafe(nil), Hash)

class TestProf::RubyProf::Report
  include ::TestProf::Logging

  def initialize(profiler); end

  def dump(name); end

  private

  def build_path(name, printer); end
  def config; end
end

module TestProf::StackProf
  extend ::TestProf::Logging

  class << self
    def config; end
    def configure; end
    def dump(name); end
    def profile(name = T.unsafe(nil)); end
    def run; end

    private

    def build_path(name); end
    def check_stack_prof_version; end
    def dump_html_report(path); end
    def dump_json_report(path); end
    def init_stack_prof; end
    def locked?; end
  end
end

class TestProf::StackProf::Configuration
  def initialize; end

  def boot?; end
  def format; end
  def format=(_arg0); end
  def ignore_gc; end
  def ignore_gc=(_arg0); end
  def interval; end
  def interval=(_arg0); end
  def mode; end
  def mode=(_arg0); end
  def raw; end
  def raw=(_arg0); end
  def raw?; end
  def suite?; end
  def target; end
  def target=(_arg0); end
end

TestProf::StackProf::Configuration::FORMATS = T.let(T.unsafe(nil), Array)
module TestProf::StringTruncate; end

module TestProf::TPSProf
  class << self
    def config; end
    def configure; end
  end
end

class TestProf::TPSProf::Configuration
  def initialize; end

  def reporter; end
  def reporter=(_arg0); end
  def threshold; end
  def threshold=(_arg0); end
  def top_count; end
  def top_count=(_arg0); end

  private

  def resolve_reporter(format); end
end

class TestProf::TPSProf::Profiler
  def initialize(top_count, threshold: T.unsafe(nil)); end

  def example_finished(id); end
  def example_started(id); end
  def group_finished(id); end
  def group_started(id); end
  def groups; end
  def threshold; end
  def top_count; end
  def total_count; end
  def total_time; end
end

module TestProf::TPSProf::Reporter; end

class TestProf::TPSProf::Reporter::Text
  include ::TestProf::Logging

  def print(profiler); end
end

module TestProf::TagProf; end
module TestProf::TagProf::Printers; end

module TestProf::TagProf::Printers::HTML
  extend ::TestProf::Logging

  class << self
    def dump(result); end
  end
end

TestProf::TagProf::Printers::HTML::OUTPUT_NAME = T.let(T.unsafe(nil), String)
TestProf::TagProf::Printers::HTML::TEMPLATE = T.let(T.unsafe(nil), String)

module TestProf::TagProf::Printers::Simple
  extend ::TestProf::Logging

  class << self
    def dump(result); end
  end
end

class TestProf::TagProf::Result
  def initialize(tag, events = T.unsafe(nil)); end

  def data; end
  def events; end
  def tag; end
  def to_json(*args); end
  def track(tag, time:, events: T.unsafe(nil)); end
end

module TestProf::Utils
  class << self
    def supported_version?(gem_version, at_least, at_most); end
    def verify_gem_version(gem_name, at_least: T.unsafe(nil), at_most: T.unsafe(nil)); end
  end
end

module TestProf::Utils::HTMLBuilder
  class << self
    def generate(data:, template:, output:); end
  end
end

class TestProf::Utils::SizedOrderedSet
  include ::Enumerable

  def initialize(max_size, sort_by: T.unsafe(nil), &block); end

  def <<(item); end
  def each(&block); end
  def empty?; end
  def size; end
  def to_a; end

  private

  def comparator; end
  def data; end
  def max_size; end
end

TestProf::VERSION = T.let(T.unsafe(nil), String)

module TestProf::Vernier
  extend ::TestProf::Logging

  class << self
    def config; end
    def configure; end
    def default_collector; end
    def dump(collector, name); end
    def profile(name = T.unsafe(nil)); end
    def run; end

    private

    def build_path(name); end
    def check_vernier_version; end
    def init_vernier; end
    def locked?; end
  end
end

class TestProf::Vernier::Configuration
  def initialize; end

  def boot?; end
  def hooks; end
  def hooks=(_arg0); end
  def interval; end
  def interval=(_arg0); end
  def mode; end
  def mode=(_arg0); end
  def suite?; end
  def target; end
  def target=(_arg0); end
end

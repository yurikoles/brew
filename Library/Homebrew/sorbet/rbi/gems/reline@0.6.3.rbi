# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reline` gem.
# Please instead update this file by running `bin/tapioca gem reline`.


module Reline
  extend ::Forwardable
  extend ::SingleForwardable

  def eof?(*args, **_arg1, &block); end

  private

  def readline(*args, **_arg1, &block); end
  def readmultiline(*args, **_arg1, &block); end

  class << self
    def add_dialog_proc(*args, **_arg1, &block); end
    def ambiguous_width(*args, **_arg1, &block); end
    def auto_indent_proc(*args, **_arg1, &block); end
    def auto_indent_proc=(*args, **_arg1, &block); end
    def autocompletion(*args, **_arg1, &block); end
    def autocompletion=(*args, **_arg1, &block); end
    def basic_quote_characters(*args, **_arg1, &block); end
    def basic_quote_characters=(*args, **_arg1, &block); end
    def basic_word_break_characters(*args, **_arg1, &block); end
    def basic_word_break_characters=(*args, **_arg1, &block); end
    def completer_quote_characters(*args, **_arg1, &block); end
    def completer_quote_characters=(*args, **_arg1, &block); end
    def completer_word_break_characters(*args, **_arg1, &block); end
    def completer_word_break_characters=(*args, **_arg1, &block); end
    def completion_append_character(*args, **_arg1, &block); end
    def completion_append_character=(*args, **_arg1, &block); end
    def completion_case_fold(*args, **_arg1, &block); end
    def completion_case_fold=(*args, **_arg1, &block); end
    def completion_proc(*args, **_arg1, &block); end
    def completion_proc=(*args, **_arg1, &block); end
    def completion_quote_character(*args, **_arg1, &block); end
    def core; end
    def delete_text(*args, **_arg1, &block); end
    def dialog_proc(*args, **_arg1, &block); end
    def dig_perfect_match_proc(*args, **_arg1, &block); end
    def dig_perfect_match_proc=(*args, **_arg1, &block); end
    def emacs_editing_mode(*args, **_arg1, &block); end
    def emacs_editing_mode?(*args, **_arg1, &block); end
    def encoding_system_needs; end
    def eof?(*args, **_arg1, &block); end
    def filename_quote_characters(*args, **_arg1, &block); end
    def filename_quote_characters=(*args, **_arg1, &block); end
    def get_screen_size(*args, **_arg1, &block); end
    def input=(*args, **_arg1, &block); end
    def insert_text(text); end
    def last_incremental_search(*args, **_arg1, &block); end
    def last_incremental_search=(*args, **_arg1, &block); end
    def line_buffer(*args, **_arg1, &block); end
    def line_editor; end
    def output=(*args, **_arg1, &block); end
    def output_modifier_proc(*args, **_arg1, &block); end
    def output_modifier_proc=(*args, **_arg1, &block); end
    def point(*args, **_arg1, &block); end
    def point=(*args, **_arg1, &block); end
    def pre_input_hook(*args, **_arg1, &block); end
    def pre_input_hook=(*args, **_arg1, &block); end
    def prompt_proc(*args, **_arg1, &block); end
    def prompt_proc=(*args, **_arg1, &block); end
    def readline(*args, **_arg1, &block); end
    def readmultiline(*args, **_arg1, &block); end
    def redisplay(*args, **_arg1, &block); end
    def special_prefixes(*args, **_arg1, &block); end
    def special_prefixes=(*args, **_arg1, &block); end
    def ungetc(c); end
    def vi_editing_mode(*args, **_arg1, &block); end
    def vi_editing_mode?(*args, **_arg1, &block); end
  end
end

class Reline::ANSI < ::Reline::IO
  def initialize; end

  def both_tty?; end
  def buffered_output; end
  def clear_screen; end
  def cursor_pos; end
  def deprep(otio); end
  def empty_buffer?; end
  def encoding; end
  def erase_after_cursor; end
  def get_screen_size; end
  def getc(timeout_second); end
  def hide_cursor; end
  def in_pasting?; end
  def inner_getc(timeout_second); end
  def input=(_arg0); end
  def move_cursor_column(x); end
  def move_cursor_down(x); end
  def move_cursor_up(x); end
  def output=(_arg0); end
  def prep; end
  def read_bracketed_paste; end
  def read_single_char(timeout_second); end
  def scroll_down(x); end
  def set_bracketed_paste_key_bindings(config); end
  def set_default_key_bindings(config); end
  def set_default_key_bindings_ansi_cursor(config); end
  def set_default_key_bindings_comprehensive_list(config); end
  def set_screen_size(rows, columns); end
  def set_winch_handler(&handler); end
  def show_cursor; end
  def ungetc(c); end
  def with_raw_input; end
  def write(string); end

  private

  def cursor_pos_internal(timeout:); end
end

Reline::ANSI::ANSI_CURSOR_KEY_BINDINGS = T.let(T.unsafe(nil), Hash)
Reline::ANSI::END_BRACKETED_PASTE = T.let(T.unsafe(nil), String)
Reline::ANSI::START_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

class Reline::Config
  def initialize; end

  def add_default_key_binding(keystroke, target); end
  def add_default_key_binding_by_keymap(keymap, keystroke, target); end
  def add_oneshot_key_binding(keystroke, target); end
  def autocompletion; end
  def autocompletion=(_arg0); end
  def bind_key(key, value); end
  def bind_variable(name, value, raw_value); end
  def completion_ignore_case; end
  def completion_ignore_case=(_arg0); end
  def convert_meta; end
  def convert_meta=(_arg0); end
  def disable_completion; end
  def disable_completion=(_arg0); end
  def editing_mode; end
  def editing_mode=(val); end
  def editing_mode_is?(*val); end
  def emacs_mode_string; end
  def emacs_mode_string=(_arg0); end
  def enable_bracketed_paste; end
  def enable_bracketed_paste=(_arg0); end
  def handle_directive(directive, file, no, if_stack); end
  def history_size; end
  def history_size=(_arg0); end
  def inputrc_path; end
  def isearch_terminators; end
  def isearch_terminators=(_arg0); end
  def key_bindings; end
  def key_notation_to_code(notation); end
  def keymap; end
  def keyseq_timeout; end
  def keyseq_timeout=(_arg0); end
  def loaded?; end
  def parse_key_binding(key, func_name); end
  def parse_keyseq(str); end
  def read(file = T.unsafe(nil)); end
  def read_lines(lines, file = T.unsafe(nil)); end
  def reload; end
  def reset; end
  def reset_oneshot_key_bindings; end
  def reset_variables; end
  def retrieve_string(str); end
  def show_all_if_ambiguous; end
  def show_all_if_ambiguous=(_arg0); end
  def show_mode_in_prompt; end
  def show_mode_in_prompt=(_arg0); end
  def test_mode; end
  def vi_cmd_mode_string; end
  def vi_cmd_mode_string=(_arg0); end
  def vi_ins_mode_string; end
  def vi_ins_mode_string=(_arg0); end

  private

  def default_inputrc_path; end
  def seven_bit_encoding?(encoding); end
end

class Reline::Config::InvalidInputrc < ::RuntimeError
  def file; end
  def file=(_arg0); end
  def lineno; end
  def lineno=(_arg0); end
end

Reline::Config::KEYSEQ_PATTERN = T.let(T.unsafe(nil), Regexp)
Reline::Config::VARIABLE_NAMES = T.let(T.unsafe(nil), Array)
Reline::Config::VARIABLE_NAME_SYMBOLS = T.let(T.unsafe(nil), Array)

class Reline::Core
  extend ::Forwardable

  def initialize; end

  def add_dialog_proc(name_sym, p, context = T.unsafe(nil)); end
  def ambiguous_width; end
  def auto_indent_proc; end
  def auto_indent_proc=(p); end
  def autocompletion(*args, **_arg1, &block); end
  def autocompletion=(*args, **_arg1, &block); end
  def basic_quote_characters; end
  def basic_quote_characters=(v); end
  def basic_word_break_characters; end
  def basic_word_break_characters=(v); end
  def completer_quote_characters; end
  def completer_quote_characters=(v); end
  def completer_word_break_characters; end
  def completer_word_break_characters=(v); end
  def completion_append_character; end
  def completion_append_character=(val); end
  def completion_case_fold; end
  def completion_case_fold=(v); end
  def completion_proc; end
  def completion_proc=(p); end
  def completion_quote_character; end
  def config; end
  def config=(_arg0); end
  def dialog_proc(name_sym); end
  def dig_perfect_match_proc; end
  def dig_perfect_match_proc=(p); end
  def emacs_editing_mode; end
  def emacs_editing_mode?; end
  def encoding; end
  def filename_quote_characters; end
  def filename_quote_characters=(v); end
  def get_screen_size; end
  def input=(val); end
  def io_gate; end
  def key_stroke; end
  def key_stroke=(_arg0); end
  def last_incremental_search; end
  def last_incremental_search=(_arg0); end
  def line_editor; end
  def line_editor=(_arg0); end
  def output; end
  def output=(val); end
  def output_modifier_proc; end
  def output_modifier_proc=(p); end
  def pre_input_hook; end
  def pre_input_hook=(p); end
  def prompt_proc; end
  def prompt_proc=(p); end
  def readline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil)); end
  def readmultiline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil), &confirm_multiline_termination); end
  def special_prefixes; end
  def special_prefixes=(v); end
  def vi_editing_mode; end
  def vi_editing_mode?; end

  private

  def inner_readline(prompt, add_hist, multiline, &confirm_multiline_termination); end
  def may_req_ambiguous_char_width; end
  def read_io(keyseq_timeout, &block); end
end

Reline::Core::ATTR_READER_NAMES = T.let(T.unsafe(nil), Array)

class Reline::Core::DialogProc < ::Struct
  def context; end
  def context=(_); end
  def dialog_proc; end
  def dialog_proc=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Reline::CursorPos < ::Struct
  def x; end
  def x=(_); end
  def y; end
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Reline::DEFAULT_DIALOG_CONTEXT = T.let(T.unsafe(nil), Array)
Reline::DEFAULT_DIALOG_PROC_AUTOCOMPLETE = T.let(T.unsafe(nil), Proc)

class Reline::DialogRenderInfo < ::Struct
  def bg_color; end
  def bg_color=(_); end
  def contents; end
  def contents=(_); end
  def face; end
  def face=(_); end
  def height; end
  def height=(_); end
  def pos; end
  def pos=(_); end
  def scrollbar; end
  def scrollbar=(_); end
  def width; end
  def width=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Reline::Dumb < ::Reline::IO
  def initialize(encoding: T.unsafe(nil)); end

  def buffered_output; end
  def clear_screen; end
  def cursor_pos; end
  def deprep(otio); end
  def dumb?; end
  def encoding; end
  def erase_after_cursor; end
  def get_screen_size; end
  def getc(_timeout_second); end
  def hide_cursor; end
  def in_pasting?; end
  def input=(val); end
  def move_cursor_column(val); end
  def move_cursor_down(val); end
  def move_cursor_up(val); end
  def output=(_arg0); end
  def prep; end
  def scroll_down(val); end
  def set_default_key_bindings(_); end
  def set_screen_size(rows, columns); end
  def set_winch_handler(&handler); end
  def show_cursor; end
  def ungetc(c); end
  def with_raw_input; end
  def write(string); end
end

Reline::Dumb::RESET_COLOR = T.let(T.unsafe(nil), String)
Reline::FILENAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

class Reline::Face
  class << self
    def [](name); end
    def config(name, &block); end
    def configs; end
    def force_truecolor; end
    def load_initial_configs; end
    def reset_to_initial_configs; end
    def truecolor?; end
  end
end

class Reline::Face::Config
  def initialize(name, &block); end

  def [](name); end
  def define(name, **values); end
  def definition; end
  def reconfigure; end

  private

  def format_to_sgr(ordered_values); end
  def rgb_expression?(color); end
  def sgr_rgb(key, value); end
  def sgr_rgb_256color(key, value); end
  def sgr_rgb_truecolor(key, value); end
end

Reline::Face::Config::ESSENTIAL_DEFINE_NAMES = T.let(T.unsafe(nil), Array)
Reline::Face::Config::RESET_SGR = T.let(T.unsafe(nil), String)
Reline::Face::SGR_PARAMETERS = T.let(T.unsafe(nil), Hash)
Reline::HISTORY = T.let(T.unsafe(nil), Reline::History)

class Reline::History < ::Array
  def initialize(config); end

  def <<(val); end
  def [](index); end
  def []=(index, val); end
  def concat(*val); end
  def delete_at(index); end
  def push(*val); end
  def to_s; end

  private

  def check_index(index); end
end

class Reline::IO
  def dumb?; end
  def read_single_char(timeout_second); end
  def reset_color_sequence; end
  def win?; end

  class << self
    def decide_io_gate; end
  end
end

Reline::IOGate = T.let(T.unsafe(nil), Reline::ANSI)

class Reline::Key < ::Struct
  def char; end
  def char=(_); end
  def match?(sym); end
  def method_symbol; end
  def method_symbol=(_); end
  def unused_boolean; end
  def unused_boolean=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Reline::KeyActor::Base
  def initialize(mappings = T.unsafe(nil)); end

  def add(key, func); end
  def add_mappings(mappings); end
  def clear; end
  def get(key); end
  def matching?(key); end
end

class Reline::KeyActor::Composite
  def initialize(key_actors); end

  def get(key); end
  def matching?(key); end
end

Reline::KeyActor::EMACS_MAPPING = T.let(T.unsafe(nil), Array)
Reline::KeyActor::VI_COMMAND_MAPPING = T.let(T.unsafe(nil), Array)
Reline::KeyActor::VI_INSERT_MAPPING = T.let(T.unsafe(nil), Array)

class Reline::KeyStroke
  def initialize(config, encoding); end

  def encoding; end
  def encoding=(_arg0); end
  def expand(input); end
  def match_status(input); end

  private

  def key_mapping; end
  def match_unknown_escape_sequence(input, vi_mode: T.unsafe(nil)); end
end

Reline::KeyStroke::CSI_INTERMEDIATE_BYTES_RANGE = T.let(T.unsafe(nil), Range)
Reline::KeyStroke::CSI_PARAMETER_BYTES_RANGE = T.let(T.unsafe(nil), Range)
Reline::KeyStroke::ESC_BYTE = T.let(T.unsafe(nil), Integer)
Reline::KeyStroke::MATCHED = T.let(T.unsafe(nil), Symbol)
Reline::KeyStroke::MATCHING = T.let(T.unsafe(nil), Symbol)
Reline::KeyStroke::MATCHING_MATCHED = T.let(T.unsafe(nil), Symbol)
Reline::KeyStroke::UNMATCHED = T.let(T.unsafe(nil), Symbol)

class Reline::KillRing
  include ::Enumerable

  def initialize(max = T.unsafe(nil)); end

  def append(string, before_p = T.unsafe(nil)); end
  def each; end
  def process; end
  def yank; end
  def yank_pop; end
end

class Reline::KillRing::RingBuffer
  def initialize(max = T.unsafe(nil)); end

  def <<(point); end
  def empty?; end
  def head; end
  def size; end
end

class Reline::KillRing::RingPoint < ::Struct
  def initialize(str); end

  def ==(other); end
  def backward; end
  def backward=(_); end
  def forward; end
  def forward=(_); end
  def str; end
  def str=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Reline::KillRing::State::CONTINUED = T.let(T.unsafe(nil), Symbol)
Reline::KillRing::State::FRESH = T.let(T.unsafe(nil), Symbol)
Reline::KillRing::State::PROCESSED = T.let(T.unsafe(nil), Symbol)
Reline::KillRing::State::YANK = T.let(T.unsafe(nil), Symbol)

class Reline::LineEditor
  def initialize(config); end

  def add_dialog_proc(name, p, context = T.unsafe(nil)); end
  def auto_indent_proc; end
  def auto_indent_proc=(_arg0); end
  def byte_pointer; end
  def byte_pointer=(val); end
  def calculate_overlay_levels(overlay_levels); end
  def call_completion_proc(pre, target, post, quote); end
  def call_completion_proc_with_checking_args(pre, target, post); end
  def clear_dialogs; end
  def completion_append_character; end
  def completion_append_character=(_arg0); end
  def completion_proc; end
  def completion_proc=(_arg0); end
  def confirm_multiline_termination; end
  def confirm_multiline_termination_proc; end
  def confirm_multiline_termination_proc=(_arg0); end
  def current_byte_pointer_cursor; end
  def current_line; end
  def delete_text(start = T.unsafe(nil), length = T.unsafe(nil)); end
  def dialog_proc_scope_completion_journey_data; end
  def dig_perfect_match_proc; end
  def dig_perfect_match_proc=(_arg0); end
  def editing_mode; end
  def encoding; end
  def eof?; end
  def finalize; end
  def finish; end
  def finished?; end
  def handle_signal; end
  def input_key(key); end
  def insert_multiline_text(text); end
  def insert_text(text); end
  def io_gate; end
  def line; end
  def modified_lines; end
  def multiline_off; end
  def multiline_on; end
  def output_modifier_proc; end
  def output_modifier_proc=(_arg0); end
  def prompt_list; end
  def prompt_proc; end
  def prompt_proc=(_arg0); end
  def push_undo_redo(modified); end
  def render; end
  def render_finished; end
  def render_line_differential(old_items, new_items); end
  def rerender; end
  def reset(prompt = T.unsafe(nil)); end
  def reset_line; end
  def reset_variables(prompt = T.unsafe(nil)); end
  def rest_height(wrapped_cursor_y); end
  def retrieve_completion_block; end
  def screen_height; end
  def screen_scroll_top; end
  def screen_width; end
  def scroll_into_view; end
  def set_current_line(line, byte_pointer = T.unsafe(nil)); end
  def set_pasting_state(in_pasting); end
  def set_signal_handlers; end
  def update(key); end
  def update_dialogs(key = T.unsafe(nil)); end
  def upper_space_height(wrapped_cursor_y); end
  def whole_buffer; end
  def whole_lines; end
  def with_cache(key, *deps); end
  def wrap_method_call(method_symbol, key, with_operator); end
  def wrapped_cursor_position; end
  def wrapped_prompt_and_input_lines; end

  private

  def argumentable?(method_obj); end
  def backward_char(key, arg: T.unsafe(nil)); end
  def backward_delete_char(key, arg: T.unsafe(nil)); end
  def backward_kill_word(key); end
  def backward_word(key); end
  def beginning_of_history(key); end
  def beginning_of_line(key); end
  def buffer_empty?; end
  def byteinsert(str, byte_pointer, other); end
  def byteslice!(str, byte_pointer, size); end
  def calculate_nearest_cursor(cursor); end
  def calculate_width(str, allow_escape_code = T.unsafe(nil)); end
  def capitalize_word(key); end
  def check_mode_string; end
  def check_multiline_prompt(buffer, mode_string); end
  def cleanup_waiting; end
  def clear_rendered_screen_cache; end
  def clear_screen(key); end
  def complete(_key); end
  def completion_journey_move(direction); end
  def completion_journey_up(_key); end
  def copy_for_vi(text); end
  def delete_char(key); end
  def delete_char_or_list(key); end
  def dialog_range(dialog, dialog_y); end
  def downcase_word(key); end
  def ed_argument_digit(key); end
  def ed_beginning_of_history(key); end
  def ed_clear_screen(key); end
  def ed_delete_next_char(key, arg: T.unsafe(nil)); end
  def ed_delete_prev_char(key, arg: T.unsafe(nil)); end
  def ed_delete_prev_word(key); end
  def ed_digit(key); end
  def ed_end_of_history(key); end
  def ed_force_submit(_key); end
  def ed_insert(str); end
  def ed_kill_line(key); end
  def ed_move_to_beg(key); end
  def ed_move_to_end(key); end
  def ed_newline(key); end
  def ed_next_char(key, arg: T.unsafe(nil)); end
  def ed_next_history(key, arg: T.unsafe(nil)); end
  def ed_prev_char(key, arg: T.unsafe(nil)); end
  def ed_prev_history(key, arg: T.unsafe(nil)); end
  def ed_prev_word(key); end
  def ed_search_next_history(key, arg: T.unsafe(nil)); end
  def ed_search_prev_history(key, arg: T.unsafe(nil)); end
  def ed_transpose_chars(key); end
  def ed_transpose_words(key); end
  def ed_unassigned(key); end
  def em_capitol_case(key); end
  def em_delete(key); end
  def em_delete_next_word(key); end
  def em_delete_or_list(key); end
  def em_delete_prev_char(key, arg: T.unsafe(nil)); end
  def em_exchange_mark(key); end
  def em_kill_line(key); end
  def em_kill_region(key); end
  def em_lower_case(key); end
  def em_next_word(key); end
  def em_set_mark(key); end
  def em_upper_case(key); end
  def em_yank(key); end
  def em_yank_pop(key); end
  def emacs_editing_mode(key); end
  def end_of_history(key); end
  def end_of_line(key); end
  def exchange_point_and_mark(key); end
  def filter_normalize_candidates(target, list); end
  def forward_char(key, arg: T.unsafe(nil)); end
  def forward_search_history(key); end
  def forward_word(key); end
  def generate_searcher(direction); end
  def handle_interrupted; end
  def handle_resized; end
  def history_search_backward(key, arg: T.unsafe(nil)); end
  def history_search_forward(key, arg: T.unsafe(nil)); end
  def inclusive?(method_obj); end
  def incremental_search_history(direction); end
  def insert_new_line(cursor_line, next_line); end
  def insert_raw_char(str, arg: T.unsafe(nil)); end
  def key_delete(key); end
  def key_newline(key); end
  def kill_line(key); end
  def kill_whole_line(key); end
  def kill_word(key); end
  def menu(list); end
  def menu_complete(_key); end
  def menu_complete_backward(_key); end
  def modify_lines(before, complete); end
  def move_completed_list(direction); end
  def move_history(history_pointer, line:, cursor:); end
  def move_undo_redo(direction); end
  def next_history(key, arg: T.unsafe(nil)); end
  def perform_completion(preposing, target, postposing, quote, list); end
  def prev_action_state_value(type); end
  def previous_history(key, arg: T.unsafe(nil)); end
  def process_auto_indent(line_index = T.unsafe(nil), cursor_dependent: T.unsafe(nil), add_newline: T.unsafe(nil)); end
  def process_insert(force: T.unsafe(nil)); end
  def process_key(key, method_symbol); end
  def re_read_init_file(_key); end
  def redo(_key); end
  def render_differential(new_lines, new_cursor_x, new_cursor_y); end
  def retrieve_completion_journey_state; end
  def reverse_search_history(key); end
  def run_for_operators(key, method_symbol); end
  def search_history(prefix, pointer_range); end
  def search_next_char(key, arg, need_prev_char: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def search_prev_char(key, arg, need_next_char = T.unsafe(nil)); end
  def self_insert(str); end
  def set_mark(key); end
  def set_next_action_state(type, value); end
  def split_line_by_width(str, max_width, offset: T.unsafe(nil)); end
  def transpose_chars(key); end
  def transpose_words(key); end
  def undo(_key); end
  def unix_line_discard(key); end
  def unix_word_rubout(key); end
  def upcase_word(key); end
  def update_each_dialog(dialog, cursor_column, cursor_row, key = T.unsafe(nil)); end
  def vi_add(key); end
  def vi_add_at_eol(key); end
  def vi_change_meta(key, arg: T.unsafe(nil)); end
  def vi_change_meta_confirm(byte_pointer_diff); end
  def vi_change_to_eol(key); end
  def vi_command_mode(key); end
  def vi_delete_meta(key, arg: T.unsafe(nil)); end
  def vi_delete_meta_confirm(byte_pointer_diff); end
  def vi_delete_prev_char(key); end
  def vi_editing_mode(key); end
  def vi_end_big_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_end_of_transmission(key); end
  def vi_end_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_eof_maybe(key); end
  def vi_first_print(key); end
  def vi_histedit(key); end
  def vi_insert(key); end
  def vi_insert_at_bol(key); end
  def vi_join_lines(key, arg: T.unsafe(nil)); end
  def vi_kill_line_prev(key); end
  def vi_list_or_eof(key); end
  def vi_movement_mode(key); end
  def vi_next_big_word(key, arg: T.unsafe(nil)); end
  def vi_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_next_word(key, arg: T.unsafe(nil)); end
  def vi_paste_next(key, arg: T.unsafe(nil)); end
  def vi_paste_prev(key, arg: T.unsafe(nil)); end
  def vi_prev_big_word(key, arg: T.unsafe(nil)); end
  def vi_prev_char(key, arg: T.unsafe(nil)); end
  def vi_prev_word(key, arg: T.unsafe(nil)); end
  def vi_replace_char(key, arg: T.unsafe(nil)); end
  def vi_search_next(key); end
  def vi_search_prev(key); end
  def vi_to_column(key, arg: T.unsafe(nil)); end
  def vi_to_history_line(key); end
  def vi_to_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_to_prev_char(key, arg: T.unsafe(nil)); end
  def vi_yank(key, arg: T.unsafe(nil)); end
  def vi_yank_confirm(byte_pointer_diff); end
  def vi_zero(key); end
  def yank(key); end
  def yank_pop(key); end
end

Reline::LineEditor::ARGUMENT_DIGIT_METHODS = T.let(T.unsafe(nil), Array)

class Reline::LineEditor::CompletionJourneyState < ::Struct
  def line_index; end
  def line_index=(_); end
  def list; end
  def list=(_); end
  def pointer; end
  def pointer=(_); end
  def post; end
  def post=(_); end
  def pre; end
  def pre=(_); end
  def target; end
  def target=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Reline::LineEditor::CompletionState::MENU = T.let(T.unsafe(nil), Symbol)
Reline::LineEditor::CompletionState::MENU_WITH_PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)
Reline::LineEditor::CompletionState::NORMAL = T.let(T.unsafe(nil), Symbol)
Reline::LineEditor::CompletionState::PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)
Reline::LineEditor::DIALOG_DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

class Reline::LineEditor::Dialog
  def initialize(name, config, proc_scope); end

  def call(key); end
  def column; end
  def column=(_arg0); end
  def contents; end
  def contents=(contents); end
  def name; end
  def pointer; end
  def pointer=(_arg0); end
  def scroll_top; end
  def scroll_top=(_arg0); end
  def set_cursor_pos(col, row); end
  def trap_key; end
  def trap_key=(_arg0); end
  def vertical_offset; end
  def vertical_offset=(_arg0); end
  def width; end
  def width=(v); end
end

class Reline::LineEditor::DialogProcScope
  def initialize(line_editor, config, proc_to_exec, context); end

  def call; end
  def call_completion_proc_with_checking_args(pre, target, post); end
  def completion_journey_data; end
  def config; end
  def context; end
  def cursor_pos; end
  def dialog; end
  def just_cursor_moving; end
  def key; end
  def preferred_dialog_height; end
  def retrieve_completion_block(_unused = T.unsafe(nil)); end
  def screen_height; end
  def screen_width; end
  def set_cursor_pos(col, row); end
  def set_dialog(dialog); end
  def set_key(key); end
end

class Reline::LineEditor::DialogProcScope::CompletionJourneyData < ::Struct
  def list; end
  def list=(_); end
  def pointer; end
  def pointer=(_); end
  def postposing; end
  def postposing=(_); end
  def preposing; end
  def preposing=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Reline::LineEditor::MAX_UNDO_REDO_HISTORY_SIZE = T.let(T.unsafe(nil), Integer)
Reline::LineEditor::MINIMUM_SCROLLBAR_HEIGHT = T.let(T.unsafe(nil), Integer)

class Reline::LineEditor::MenuInfo
  def initialize(list); end

  def lines(screen_width); end
  def list; end
end

Reline::LineEditor::NullActionState = T.let(T.unsafe(nil), Array)

class Reline::LineEditor::RenderedScreen < ::Struct
  def base_y; end
  def base_y=(_); end
  def cursor_y; end
  def cursor_y=(_); end
  def lines; end
  def lines=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Reline::LineEditor::VI_MOTIONS = T.let(T.unsafe(nil), Array)
Reline::LineEditor::VI_WAITING_ACCEPT_METHODS = T.let(T.unsafe(nil), Array)
Reline::USERNAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

class Reline::Unicode
  class << self
    def calculate_width(str, allow_escape_code = T.unsafe(nil)); end
    def common_prefix(list, ignore_case: T.unsafe(nil)); end
    def east_asian_width(ord); end
    def ed_transpose_words(line, byte_pointer); end
    def em_backward_word(line, byte_pointer); end
    def em_big_backward_word(line, byte_pointer); end
    def em_forward_word(line, byte_pointer); end
    def em_forward_word_with_capitalization(line, byte_pointer); end
    def escape_for_print(str); end
    def get_mbchar_width(mbchar); end
    def get_next_mbchar_size(line, byte_pointer); end
    def get_prev_mbchar_size(line, byte_pointer); end
    def safe_encode(str, encoding); end
    def space_character?(s); end
    def split_by_width(str, max_width); end
    def split_line_by_width(str, max_width, encoding = T.unsafe(nil), offset: T.unsafe(nil)); end
    def strip_non_printing_start_end(prompt); end
    def take_mbchar_range(str, start_col, width, cover_begin: T.unsafe(nil), cover_end: T.unsafe(nil), padding: T.unsafe(nil)); end
    def take_range(str, start_col, max_width); end
    def vi_backward_word(line, byte_pointer); end
    def vi_big_backward_word(line, byte_pointer); end
    def vi_big_forward_end_word(line, byte_pointer); end
    def vi_big_forward_word(line, byte_pointer); end
    def vi_first_print(line); end
    def vi_forward_end_word(line, byte_pointer); end
    def vi_forward_word(line, byte_pointer, drop_terminate_spaces = T.unsafe(nil)); end
    def word_character?(s); end
  end
end

Reline::Unicode::CSI_REGEXP = T.let(T.unsafe(nil), Regexp)
Reline::Unicode::EastAsianWidth::CHUNK_LAST = T.let(T.unsafe(nil), Array)
Reline::Unicode::EastAsianWidth::CHUNK_WIDTH = T.let(T.unsafe(nil), Array)
Reline::Unicode::EscapedPairs = T.let(T.unsafe(nil), Hash)
Reline::Unicode::NON_PRINTING_END = T.let(T.unsafe(nil), String)
Reline::Unicode::NON_PRINTING_START = T.let(T.unsafe(nil), String)
Reline::Unicode::OSC_REGEXP = T.let(T.unsafe(nil), Regexp)
Reline::Unicode::WIDTH_SCANNER = T.let(T.unsafe(nil), Regexp)
Reline::VERSION = T.let(T.unsafe(nil), String)
